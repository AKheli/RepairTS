<script>
    const recommendationHandler = {
        init: function (option, start_url, retrieve_url) {
            this.data = []
            this.iteration = 0;
            this.task_id = '{{csrf_token}}'
            this.playing = false
            this.computing = false
            this.intervalTimer = 1000
            this.option = option//flaml or ray
            this.start_url = start_url
            this.retrieve_url = retrieve_url
            this.timeoutID = null
            RecommendationChart.init()

        },
        start: function () {
            RecommendationChart.init()
            this.iteration = 0;
            this.data = [];
            this.flaml_series = []

            if (this.timeoutID != null) {
                clearTimeout(this.timeoutID); // Clear the ongoing timeout/iteration
            }

            let queryString = $('#recommendation_settings_form').serialize();
            const params = new URLSearchParams(queryString);
            const estimatorList = params.getAll("estimator_list");
            queryString += '&estimator_list=' + estimatorList;

            document.getElementById("play-recommendation-info-text").innerHTML = "Starting " + this.option;
            RecommendationChart.chart.showLoading()

            $.ajax({
                type: 'POST',
                url: this.start_url,
                data: $('#start-form').serialize() + '&' + $('#ray_tune_settings_form').serialize() + '&' + queryString + '&tuner=' + this.option + '&task_id=' + this.task_id,
                success: (response) => {
                    let estimators = response.automl_settings.estimator_list;
                    // Display message that Flaml is running
                    // Call function to retrieve Flaml results periodically
                    // Create chart
                    document.getElementById("play-recommendation-info-text").innerHTML = "Starting " + this.option + "..."
                    this.getResults();
                    this.iterateData();
                    RecommendationChart.chart.hideLoading()
                    const parameterNames = {
                        "RandomForest": ["n_estimators", "max_features", "max_leaf_nodes"],
                        "ExtraTrees": ["n_estimators", "max_features", "max_leaf_nodes"],
                        "LogisticRegression": ["C"],
                        "LGBM": ["n_estimators", "num_leaves", "learning_rate", "min_child_samples"],
                        "XGBoostSklearn": ["n_estimators", "max_depth", "learning_rate", "min_child_weight", "reg_alpha", "reg_lambda"]
                    };
                    if (this.option !== "ray") {
                        parameterTable.init(parameterNames);
                        parameterTable.data = [];
                    }
                },
                error: function (response) {
                    console.log(response);
                }
            });

        },

        getResults: function () {
            $.ajax({
                type: 'POST',
                url: this.retrieve_url,
                data: $('#start-form').serialize() + '&task_id=' + this.task_id,
                success: response => {
                    if (response.status === 'running') {
                        this.data = response.data;
                        RecommendationChart.chart.redraw();
                        setTimeout(() => {
                            this.getResults();  // Pass the task_id again in the recursive call
                        }, 1000);
                    } else if (response.status === 'done') {

                        const elements = document.querySelectorAll('.disable-mouse-events');
                        elements.forEach(function (element) {
                            element.classList.remove('disable-mouse-events');
                            element.classList.add('disable-mouse-events-removed')
                        });

                        showRecommendationBelow()

                        // Display message that Flaml is finished
                        // ...
                        {#getPrediction()#}

                    }
                },
                error: function (response) {
                    alert('Error retrieving Flaml results');
                }
            });
        },

        iterateData: function () {
            if (this.iteration < this.data.length && this.playing) {
                let currentData = this.data[this.iteration];

                let score = currentData.score;
                let roundedScore = Math.round(score * 1000) / 1000;
                let estimator = currentData.estimator
                let parameters = currentData.parameters
                let runtime = currentData.runtime
                document.getElementById("play-recommendation-info-text").innerHTML = "Iter:" + this.iteration +
                    "| Estimator: " + estimator +
                    " | " + runtime + "s" +
                    " | Score: " + roundedScore;

                this.iteration = this.iteration + 1;
                this.flaml_series.push({y: score, x: this.iteration, name: estimator})
                RecommendationChart.addData(score, estimator, this.iteration, parameters);
                parameterTable.addData(roundedScore, estimator, parameters);
                {#addDataToFlamlChart(score, currentData.estimator , 1);#}
            } else {
                if (this.playing) {
                }
            }

            this.timeoutID = setTimeout(this.iterateData.bind(this), this.intervalTimer);
        }

    }

    registerPlayAndReloadBtns("recommendation", recommendationHandler)

    const parameterTable = {
        tableId: "parameterTable",
        data: [],
        parameter_names: null,
        intervalTimer: 1000,
        hasStarted: false,
        playing: false,
        timeoutID: null,
        iteration: 0,

        init: function (parameter_names) {
            this.iteration = 0;
            this.parameter_names = parameter_names;
            const table = document.getElementById(this.tableId); // Get the table element by its ID

            table.innerHTML = ""; // Clear the table


            // Create a new row for the header
            const headerRow = document.createElement("tr");

            // Create and populate cells for the header row
            const estimatorHeaderCell = document.createElement("th");
            estimatorHeaderCell.textContent = "Estimator";
            headerRow.appendChild(estimatorHeaderCell);

            const parametersHeaderCell = document.createElement("th");
            parametersHeaderCell.textContent = "Parameters";
            headerRow.appendChild(parametersHeaderCell);

            const scoreHeaderCell = document.createElement("th");
            scoreHeaderCell.textContent = "Score";
            headerRow.appendChild(scoreHeaderCell);
            // Append the header row to the table
            table.appendChild(headerRow);

            // Iterate through the parameter_names and create rows for each estimator
            for (const [estimator, parameters] of Object.entries(parameter_names)) {
                const newRow = document.createElement("tr");
                newRow.setAttribute("data-estimator", estimator); // Set a custom attribute to identify the row

                // Create and populate cells for the estimator row

                const estimatorCell = document.createElement("td");
                estimatorCell.textContent = estimator;
                newRow.appendChild(estimatorCell);

                const parametersCell = document.createElement("td");
                parametersCell.className = "parameters-cell";
                {#parametersCell.textContent = "-"; // Set "-" for parameters#}
                parameters.forEach(function (name) {
                    const parameterElement = document.createElement("p");
                    parameterElement.textContent = `${name}: -`;
                    parametersCell.appendChild(parameterElement);
                });


                newRow.appendChild(parametersCell);

                const scoreCell = document.createElement("td");
                scoreCell.className = "score-cell";
                scoreCell.textContent = "-";
                newRow.appendChild(scoreCell);


                // Append the new row to the table
                table.appendChild(newRow);

                this.data[estimator] = {
                    score: "-",
                    parameters: "-"
                };
            }
        },

        addData: function (score, estimator, parameters) {
            this.data.push({
                score: score,
                estimator: estimator,
                parameters: parameters
            });

            {#this.showData(score, estimator, parameters);#}
        },

        showData: function (score, estimator, parameters) {
            if (this.data.hasOwnProperty(estimator)) {
                // If the estimator already exists, update its content
                this.data[estimator] = {
                    score: score,
                    parameters: parameters
                };

                const table = document.getElementById(this.tableId); // Get the table element by its ID
                // remove class from all rows
                const rows = table.querySelectorAll("tr");
                rows.forEach(function (row) {
                    row.classList.remove("current-row");
                });
                table.querySelector(`tr[data-estimator="${estimator}"]`);
                const row = table.querySelector(`tr[data-estimator="${estimator}"]`); // Find the row with the matching estimator
                row.classList.add("current-row"); // Add a highlight class to the row
                // renve class after 1 second

                // Update the score and parameters cells for the existing row
                const scoreCell = row.querySelector(".score-cell");
                scoreCell.textContent = score;

                const parametersCell = row.querySelector(".parameters-cell");
                parametersCell.innerHTML = ""; // Clear the existing content

                // Iterate through the parameters and create a new <p> element for each parameter
                for (const [key, value] of Object.entries(parameters)) {
                    const parameterElement = document.createElement("p");
                    parameterElement.textContent = `${key}: ${value}`;
                    parametersCell.appendChild(parameterElement);
                }
            } else {
                // If the estimator doesn't exist, create a new entry
                this.data[estimator] = {
                    score: score,
                    parameters: parameters
                };

                const table = document.getElementById(this.tableId); // Get the table element by its ID
                const rows = table.querySelectorAll("tr");
                rows.forEach(function (row) {
                    row.classList.remove("current-row");
                });
                // Create a new row for the data
                const newRow = document.createElement("tr");
                newRow.setAttribute("data-estimator", estimator); // Set a custom attribute to identify the row
                newRow.classList.add("current-row")
                // Create and populate cells for the score, estimator, and parameters
                const scoreCell = document.createElement("td");
                scoreCell.className = "score-cell";
                scoreCell.textContent = score;
                newRow.appendChild(scoreCell);

                const estimatorCell = document.createElement("td");
                estimatorCell.textContent = estimator;
                newRow.appendChild(estimatorCell);

                const parametersCell = document.createElement("td");
                parametersCell.className = "parameters-cell";

                // Iterate through the parameters and create a new <p> element for each parameter
                for (const [key, value] of Object.entries(parameters)) {
                    const parameterElement = document.createElement("p");
                    parameterElement.textContent = `${key}: ${value}`;
                    parametersCell.appendChild(parameterElement);
                }

                newRow.appendChild(parametersCell);

                // Append the new row to the table
                table.appendChild(newRow);
            }
        },

        start() {
            this.init(this.parameter_names)
            this.replayHistory()
        },

        replayHistory: function () {
            if (this.iteration < this.data.length && this.playing) {
                const dataPoint = this.data[this.iteration];
                this.showData(dataPoint.score, dataPoint.estimator, dataPoint.parameters);
                this.iteration += 1
            }
            if (this.iteration < this.data.length) {
                this.timeoutID = setTimeout(this.replayHistory.bind(this), this.intervalTimer);
            }

        }


    }
    registerPlayAndReloadBtns("recommendation-table", parameterTable)


</script>