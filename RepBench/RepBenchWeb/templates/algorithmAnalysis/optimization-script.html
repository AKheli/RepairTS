<script>
    let repair_opt = (alg_type, parameters) => {
        let requestBody = {
            alg_type: alg_type,
            "csrfmiddlewaretoken": '{{csrf_token}}',
            ...parameters
        };
        const formDataOpt = new FormData();

        for (let key in requestBody) {
            if (requestBody.hasOwnProperty(key)) {
                formDataOpt.append(key, requestBody[key]);
            }
        }

        {#createScoreBoard();#}
        chartManager.hideNoneInjectedSeries();
        mainChart.showLoading();
        fetch(repair_url, {
            method: 'POST',
            body: formDataOpt,
        }).then(response => response.json()).then(responseJson => {
            const repSeries = responseJson.repaired_series;
            {#const scores = responseJson.scores;#}
            repairResult = repSeries;
            const chartRepairSeries = Object.keys(repSeries).map(key => {
                let repair = repSeries[key];
                return chartManager.addSeries(repair, true, "repair");
            });

            {#scores["color"] = mainChart.series[mainChart.series.length - 2].color;#}
            {#updateScoreBoard(scores);#}
        }).finally(() => {
            mainChart.hideLoading();
        });
    };


    let OptFormData = function (task_id) {
        var e = document.getElementById("optimization-form");
        const bayesienOptFormData = new FormData(e)
        bayesienOptFormData.append("setname", JSON.stringify(setname))
        bayesienOptFormData.append("task_id", task_id)
        bayesienOptFormData.append("csrfmiddlewaretoken", '{{csrf_token}}')
        return bayesienOptFormData
    }

    const optimizationHandler = {
        reInit: function (option, start_url, retrieve_url) {
            this.data = []
            this.iteration = 0;
            this.option = option //successive_halving or bayesian_optimization
            this.start_url = start_url
            this.retrieve_url = retrieve_url
        },

        init: function (option, start_url, retrieve_url) {
            this.data = []
            this.iteration = 0;
            this.task_id = '{{csrf_token}}'
            this.playing = false
            this.computing = false
            this.intervalTimer = 1000
            this.option = option //successive_halving or bayesian_optimization
            this.start_url = start_url
            this.retrieve_url = retrieve_url
            this.timeoutID = null
            document.getElementById("play-optimization-info-text").innerHTML = "Iteration:" + "-" +
                " | " + "runtime: - " + "s"
        },
        stopIteration: function () {
            clearTimeout(this.timeoutID); // Clear the ongoing timeout
        },

        start: function () {
            this.iteration = 0;
            this.data = [];
            document.getElementById("play-optimization-info-text").innerHTML = "Iteration:" + "-" +
                " | " + "runtime: - " + "s"
            SuccessiveHalvingChart.clear()
            ErrorChart.clear()

            if(this.timeoutID != null) {
                clearTimeout(this.timeoutID); // Clear the ongoing timeout/iteration
            }
            console.log("START OPTIMIZATION")
            $.ajax({
                type: 'POST',
                url: this.start_url,
                data: $("#optimization-form").serialize() + '&task_id=' + this.task_id +
                    '&setname=' + setname +
                    '&injected_series=' + JSON.stringify(chartManager.get_injected_norm_data()),
                success: (response) => {
                    {#document.getElementById("start-button-right-text").innerHTML = "Starting " + this.option + "..."#}
                    this.getResults();
                    this.iterateData();
                    {#RecommendationChart.chart.hideLoading()#}
                    optimData = response
                },
                error: function (response) {
                    console.log(response);
                }
            });

        },

        getResults: function () {
            $.ajax({
                type: 'POST',
                url: this.retrieve_url,
                data: $('#start-form').serialize() + '&task_id=' + this.task_id,
                success: response => {
                    if (response.status === 'running') {
                        this.data = response.data;
                        {#RecommendationChart.chart.redraw();#}
                        setTimeout(() => {
                            this.getResults();  // Pass the task_id again in the recursive call
                        }, 1000);
                    } else if (response.status === 'done') {
                        this.data = response.data;
                        this.computing = false
                        let last_data = this.data[this.data.length - 1]
                        repair_opt(last_data.algorithm, last_data.params)
                    }
                    {#this.data = response.data;#}
                },
                error: function (response) {
                    alert('Error retrieving optimization results');
                }
            });
        },

        iterateData: function () {
            if (this.iteration < this.data.length && this.playing) {
                let currentData = this.data[this.iteration];
                document.getElementById("play-optimization-info-text").innerHTML = "Iteration:" + (this.iteration + 1) +
                    " | " + currentData.runtime + "s"
                {#" | Score: " + currentData;#}


                if (this.option === 'successive_halving') {
                    let params = currentData.param_combinations
                    let param_names = Object.keys(params[0])
                    SuccessiveHalvingChart.setParamNames(param_names[0], param_names[1])
                    SuccessiveHalvingChart.update(params)
                    ErrorChart.add(currentData.avg_error)

                } else {
                    ErrorChart.add(currentData.score)
                    let params = currentData.params
                    let param_names = Object.keys(params)
                    SuccessiveHalvingChart.setParamNames(param_names[0], param_names[1])
                    SuccessiveHalvingChart.add(params ,currentData.score)
                }

                this.iteration += 1;
            } else {
                if (this.playing) {
                }
            }
            this.timeoutID = setTimeout(this.iterateData.bind(this), this.intervalTimer);
        }
    }
    registerPlayAndReloadBtns("optimization", optimizationHandler)
</script>